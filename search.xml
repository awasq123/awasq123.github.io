<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Wolvctf-re wp</title>
    <url>/2025/03/24/Wolvctf-re/</url>
    <content><![CDATA[<p>第一篇文章，简单记录一下WolvCTF 2025</p>
<p>作为一名密码手，这次尝试了一下逆向的题目，还是有不少收获的。其中Vinyl比较可惜吧，比赛时没关注到题目文件的更新（有一些重要提示），导致一直卡在最后一步。</p>
<p>接下来对几道题目进行一下复盘。</p>
<h3 id="CrackMeEXE"><a href="#CrackMeEXE" class="headerlink" title="CrackMeEXE"></a>CrackMeEXE</h3><p>拖入IDA发现函数很少，检查一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20011707.png"
                      alt="Test"
                ></p>
<p>使用upx脱壳</p>
<p>审计代码，逻辑是用户输入密码，然后调用加密过的unk_140005080函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20004251.png"
                      alt="Test"
                ></p>
<p>找出该内存处对应的139字节，并找到加密逻辑</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20004442.png"
                      alt="Test"
                ></p>
<p>发现设置了一个固定种子并进行异或，则我们按照相同的逻辑解密</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encrypted[] = &#123;</span><br><span class="line">        <span class="number">0x12</span>, <span class="number">0xA7</span>, <span class="number">0xE4</span>, <span class="number">0x21</span>, <span class="number">0xF3</span>, <span class="number">0xB0</span>, <span class="number">0xC6</span>, <span class="number">0xB6</span>, <span class="number">0x7A</span>, <span class="number">0x95</span>, <span class="number">0x5D</span>, <span class="number">0x7F</span>, <span class="number">0x8B</span>, <span class="number">0xED</span>, <span class="number">0x96</span>, <span class="number">0xE9</span>,</span><br><span class="line">        <span class="number">0x45</span>, <span class="number">0x4D</span>, <span class="number">0x10</span>, <span class="number">0xCF</span>, <span class="number">0x7C</span>, <span class="number">0xDD</span>, <span class="number">0xF1</span>, <span class="number">0x31</span>, <span class="number">0xDA</span>, <span class="number">0xF4</span>, <span class="number">0xFE</span>, <span class="number">0x8A</span>, <span class="number">0xEA</span>, <span class="number">0x36</span>, <span class="number">0xBD</span>, <span class="number">0x22</span>,</span><br><span class="line">        <span class="number">0xBF</span>, <span class="number">0x63</span>, <span class="number">0xCB</span>, <span class="number">0x27</span>, <span class="number">0x8A</span>, <span class="number">0x4F</span>, <span class="number">0xC6</span>, <span class="number">0xDF</span>, <span class="number">0xB2</span>, <span class="number">0x93</span>, <span class="number">0x10</span>, <span class="number">0x31</span>, <span class="number">0xED</span>, <span class="number">0x92</span>, <span class="number">0xC6</span>, <span class="number">0x49</span>,</span><br><span class="line">        <span class="number">0xA4</span>, <span class="number">0x62</span>, <span class="number">0x7B</span>, <span class="number">0xFC</span>, <span class="number">0x46</span>, <span class="number">0xA3</span>, <span class="number">0x3A</span>, <span class="number">0x15</span>, <span class="number">0x50</span>, <span class="number">0x61</span>, <span class="number">0x5C</span>, <span class="number">0xC9</span>, <span class="number">0x05</span>, <span class="number">0x9C</span>, <span class="number">0xA7</span>, <span class="number">0xFF</span>,</span><br><span class="line">        <span class="number">0xF1</span>, <span class="number">0xD0</span>, <span class="number">0x80</span>, <span class="number">0x98</span>, <span class="number">0x68</span>, <span class="number">0x07</span>, <span class="number">0x82</span>, <span class="number">0xC5</span>, <span class="number">0x36</span>, <span class="number">0x54</span>, <span class="number">0x62</span>, <span class="number">0x37</span>, <span class="number">0xF9</span>, <span class="number">0xB4</span>, <span class="number">0xA7</span>, <span class="number">0x41</span>,</span><br><span class="line">        <span class="number">0x46</span>, <span class="number">0x14</span>, <span class="number">0xCC</span>, <span class="number">0xD1</span>, <span class="number">0x0D</span>, <span class="number">0x9B</span>, <span class="number">0x1F</span>, <span class="number">0xB8</span>, <span class="number">0xBF</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0xEC</span>, <span class="number">0x50</span>, <span class="number">0x1C</span>, <span class="number">0x18</span>, <span class="number">0x5D</span>,</span><br><span class="line">        <span class="number">0x57</span>, <span class="number">0x61</span>, <span class="number">0xF1</span>, <span class="number">0x81</span>, <span class="number">0xB5</span>, <span class="number">0xC3</span>, <span class="number">0xA7</span>, <span class="number">0x38</span>, <span class="number">0xCB</span>, <span class="number">0xD6</span>, <span class="number">0xA0</span>, <span class="number">0x14</span>, <span class="number">0x8A</span>, <span class="number">0x2C</span>, <span class="number">0xF9</span>, <span class="number">0x66</span>,</span><br><span class="line">        <span class="number">0xB5</span>, <span class="number">0x39</span>, <span class="number">0xB9</span>, <span class="number">0xE8</span>, <span class="number">0xAA</span>, <span class="number">0xA7</span>, <span class="number">0x4C</span>, <span class="number">0x6A</span>, <span class="number">0xE3</span>, <span class="number">0x4C</span>, <span class="number">0x55</span>, <span class="number">0x43</span>, <span class="number">0x0C</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0xBF</span>,</span><br><span class="line">        <span class="number">0x63</span>, <span class="number">0x07</span>, <span class="number">0xF9</span>, <span class="number">0xE2</span>, <span class="number">0xDF</span>, <span class="number">0xF3</span>, <span class="number">0xF5</span>, <span class="number">0xFD</span>, <span class="number">0x6A</span>, <span class="number">0x3C</span>, <span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    srand(<span class="number">0x3419</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> decrypted[<span class="keyword">sizeof</span>(encrypted)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(encrypted); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> key = rand();    </span><br><span class="line">        <span class="type">char</span> byte_key = key ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        decrypted[i] = encrypted[i] ^ byte_key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decrypted Data (%zu bytes):\n&quot;</span>, <span class="keyword">sizeof</span>(decrypted));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(decrypted); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, decrypted[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;decrypted.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fwrite(decrypted, <span class="number">1</span>, <span class="keyword">sizeof</span>(decrypted), fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>得到二进制文件，再将其拖进cutter观察其逻辑</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20005054.png"
                      alt="Test"
                ></p>
<p>发现是将uStack_10作为密钥异或栈上存储的值并与用户输入值进行比较，按照地址顺序解密可得</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">encrypted = [</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0x0f</span>, <span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x1d</span>, <span class="number">0x2d</span>, <span class="number">0x0f</span>, <span class="number">0x09</span>,</span><br><span class="line">    <span class="number">0x56</span>, <span class="number">0x15</span>, <span class="number">0x52</span>, <span class="number">0x03</span>, <span class="number">0x39</span>, <span class="number">0x35</span>, <span class="number">0x52</span>, <span class="number">0x13</span>,</span><br><span class="line">    <span class="number">0x59</span>, <span class="number">0x11</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">key = [<span class="number">0x66</span>, <span class="number">0x6C</span>, <span class="number">0x61</span>, <span class="number">0x67</span>]</span><br><span class="line">flag = <span class="built_in">bytes</span>([encrypted[i] ^ key[i % <span class="number">4</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>)])</span><br><span class="line"><span class="built_in">print</span>(flag.decode(errors=<span class="string">&#x27;ignore&#x27;</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#wctf&#123;Ann0y3d_Y3t?&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h3><p>一道很有意思的题目</p>
<p>首先拖进IDA审计代码,发现程序一开始调用了urandom给byte_4040A9赋了一个随机值,同时把这个值也赋给byte_4040AA。</p>
<p>然后进入打工环节。余额储存在dword_404080,每天的初始工资储存在dword_404084。</p>
<p>主要有三个功能1，2，3，1是调用sub_4011C6，这是最关键的函数，通过将byte_4040AA与byte_404088到byte_40408E之间的7个字节按位与，如果不为0则输出一些语句，可以通过这些输出来确定byte_4040AA的一些位,最后会将byte_4040AA与新余额异或并赋值给自己。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20002815.png"
                      alt="Test"
                ></p>
<p>2是改变自己的工资。3是辞职并且判断257 * (unsigned __int8)byte_4040A9 &#x3D;&#x3D; dword_404080,如果成立则输出flag。</p>
<p>观察2进制文件得到余额的初始值是1337，工资的初始值是10</p>
<p>byte_404088到byte_40408E的字节分别是</p>
<blockquote>
<p>0000 1010</p>
<p>0001 0110</p>
<p>0001 1000</p>
<p>0010 1000</p>
<p>1010 1000</p>
<p>0110 0000</p>
<p>0000 0001</p>
</blockquote>
<p>接下来我们可以通过不断的调用函数1来获取输出，目的是获取初始的byte_4040AA，进而获取byte_4040A9。</p>
<p>因为所有过程都是可以预知的，并且按理来说方程是无限的，一定可以解出byte_4040AA</p>
<p>进入实战，我挑选了一次运气比较好的初始值使得我可以仅通过一次调用就获取byte_4040AA</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20003011.png"
                      alt="Test"
                ></p>
<p>可以看到只有三条语句输出，这已经可以确定byte_4040AA的所有位，即0100 0101</p>
<p>那么(unsigned __int8)byte_4040A9即为69</p>
<p>则我们让余额涨到257*69&#x3D;17733即可，计算出还差16386，改变工资后再工作一天，辞职结束!</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-23%20003347.png"
                      alt="Test"
                ></p>
<h3 id="AngerIssues"><a href="#AngerIssues" class="headerlink" title="AngerIssues"></a>AngerIssues</h3><p>拖入ida初步查看，可以看到main函数调用了checks函数，而checks函数调用了一堆funci函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20163818.png"
                      alt="Test"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20163827.png"
                      alt="Test"
                ></p>
<p>且每个函数都执行一些简单的比较功能</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20163108.png"
                      alt="Test"
                ></p>
<p>显然不能手动分析，使用自动分析工具angr</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&quot;./angerissue&quot;</span>, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_size = <span class="number">60</span>  </span><br><span class="line">flag_chars = [claripy.BVS(<span class="string">f&#x27;flag_<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(input_size)]</span><br><span class="line">flag = claripy.Concat(*flag_chars + [claripy.BVV(<span class="string">b&#x27;\n&#x27;</span>)]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state = proj.factory.full_init_state(</span><br><span class="line">    args=[<span class="string">&quot;./program&quot;</span>],</span><br><span class="line">    stdin=flag</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> flag_chars:</span><br><span class="line">    state.solver.add(c &gt;= <span class="number">0x20</span>, c &lt;= <span class="number">0x7E</span>)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Yay! You did it!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    solution_state = simgr.found[<span class="number">0</span>]</span><br><span class="line">    solution = solution_state.solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Found solution: <span class="subst">&#123;solution.decode()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] No solution found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#wctf&#123;1_h0p3_y0u_u53d_ANGR_f0r_th15_0r_y0U_w0uLd_b3_a_duMMy&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Vinyl"><a href="#Vinyl" class="headerlink" title="Vinyl"></a>Vinyl</h3><p>一道迷宫的题目</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20164336.png"
                      alt="Test"
                ></p>
<p>用户输入作为迷宫的操作，sub_1C48是主要验证逻辑。而sub_1ED4是后面更新后的文件加入的函数，主要作用是限制了一些步数处的操作，防止多解。</p>
<p>先来分析主要的迷宫函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20165036.png"
                      alt="Test"
                ></p>
<p>我愿称之为“双面重力迷宫”。不妨假设有个小人在其中移动。</p>
<p>可以看到有三个坐标,dword_5020,dword_5024,dword_5028。分别对应面的编号和位置，可以将5024看作y坐标，5028看作x坐标。迷宫单面大小是96<em>96(bytes），其中小人现在的位置用字符’X’表示，障碍用’#’表示。用户输入的每一字节按照2bits分为四组，分别对应一次操作（可能是0,1,2,3），一共有$32</em>4&#x3D;128$次操作。通过分析sub_1A8A发现四种操作分别是</p>
<blockquote>
<p>3: RL 背面顺时针旋转（迷宫本身），当前面逆时针旋转（迷宫本身），小人不翻面且坐标跟随着一块旋转。</p>
<p>2: VF 正面和背面的上下翻转（迷宫本身），小人翻面且坐标上下翻转</p>
<p>1: HF  迷宫本身不动，小人翻面且坐标左右翻转</p>
<p>0: RR 当前面顺时针旋转（迷宫本身），背面逆时针旋转（迷宫本身），小人不翻面且坐标跟随着一块旋转。</p>
</blockquote>
<p>做完这些操作之后后面都要跟上一步“重力作用”，即y坐标一直增加直到遇见障碍物。</p>
<p>迷宫构造大致如下（有点吓人）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%5Cimages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20171511.png"
                      alt="Test"
                ></p>
<p>接下来正式进入路径寻找环节。</p>
<p>首先其实提取文件中迷宫数据可以发现除了’#’作为障碍物，’.’作为路径意外，还有‘@’，这个字符的作用在题目中其实并没有说明，但实际上是对最终走到出口的正确路径的提示。</p>
<p>同时还有一个sub_1229函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20171920.png"
                      alt="Test"
                ></p>
<p>发现每走4步sub_1C48会调用一次该函数对目前的坐标进行验证，可以看作“存档点”。一共有8个（最后一个是终点）</p>
<blockquote>
<p>CHECKPOINTS &#x3D; [</p>
<p>    [0, 28, 34],</p>
<p>    [0, 35, 32],</p>
<p>    [1, 26, 15],</p>
<p>    [0, 20, 33],</p>
<p>    [1, 31, 17],</p>
<p>    [0, 60, 89],</p>
<p>    [0, 46, 51],</p>
<p>    [0, 44, 85]</p>
<p>]</p>
</blockquote>
<p>在更新题目文件之前所有有用信息就到此结束了，而我当时选择的bruteforce每四个字节，却得到了多组可能路径，并且由于枚举空间确实有点大（$10^8$左右），最后有点可惜没有做出来（没看discord，题目文件更新了:(</p>
<p>而之前提到的sub_1ED4函数就解决了这个问题，它直接告诉了我们flag中的许多字符，使得每两个存档点之间（4个字节）只有一个或者两个字节未知（$2^8$），完全可以通过bruteforce做出来</p>
<p>接下来是我实现迷宫的C代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPS 16</span></span><br><span class="line"><span class="type">int</span> state[<span class="number">3</span>] = &#123; <span class="number">0</span>,<span class="number">48</span>,<span class="number">48</span> &#125;;<span class="comment">//初始状态</span></span><br><span class="line"><span class="type">int</span> state_copy[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">2</span>][N * N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> maze[<span class="number">2</span>][N*N] =&#123;&#125;;<span class="comment">//迷宫数据，太大了不放进来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺时针旋转90度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate_clockwise</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp[N*N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            temp[j*N+N - <span class="number">1</span> - i] = maze[c][i*N+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            maze[c][i*N+j] = temp[i*N+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆时针旋转90度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate_counterclockwise</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp[N*N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            temp[(N - <span class="number">1</span> - j)*N+i] = maze[c][i*N+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            maze[c][i*N+j] = temp[i*N+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下翻转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flip_vertical</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = maze[c][i*N+j];</span><br><span class="line">            maze[c][i*N+j] = maze[c][(N - <span class="number">1</span> - i)*N+j];</span><br><span class="line">            maze[c][(N - <span class="number">1</span> - i)*N+j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右翻转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flip_horizontal</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = maze[c][i*N+j];</span><br><span class="line">            maze[c][i*N+j] = maze[c][i*N+N - <span class="number">1</span> - j];</span><br><span class="line">            maze[c][i*N+N - <span class="number">1</span> - j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_matrix</span><span class="params">(<span class="type">int</span> state[<span class="number">3</span>])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">96</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i ==state[<span class="number">1</span>] &amp;&amp; j == state[<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[31mX\033[0m&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maze[state[<span class="number">0</span>]][i * <span class="number">96</span> + j] == <span class="number">35</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maze[state[<span class="number">0</span>]][i * <span class="number">96</span> + j] == <span class="number">46</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] == <span class="number">35</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> choice, <span class="type">int</span> state[<span class="number">3</span>])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">        rotate_clockwise(state[<span class="number">0</span>]);</span><br><span class="line">        rotate_counterclockwise(<span class="number">1</span> - state[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> temp = state[<span class="number">1</span>];</span><br><span class="line">        state[<span class="number">1</span>] = state[<span class="number">2</span>];</span><br><span class="line">        state[<span class="number">2</span>] = <span class="number">95</span> - temp;</span><br><span class="line">        <span class="keyword">while</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] != <span class="number">35</span>) &#123;</span><br><span class="line">            state[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        state[<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>) &#123;</span><br><span class="line">        rotate_clockwise(<span class="number">1</span> - state[<span class="number">0</span>]);</span><br><span class="line">        rotate_counterclockwise(state[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> temp = state[<span class="number">2</span>];</span><br><span class="line">        state[<span class="number">2</span>] = state[<span class="number">1</span>];</span><br><span class="line">        state[<span class="number">1</span>] = <span class="number">95</span> - temp;</span><br><span class="line">        <span class="keyword">while</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] != <span class="number">35</span>) &#123;</span><br><span class="line">            state[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        state[<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">        state[<span class="number">0</span>] = <span class="number">1</span> - state[<span class="number">0</span>];</span><br><span class="line">        state[<span class="number">2</span>] = <span class="number">95</span> - state[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] != <span class="number">35</span>) &#123;</span><br><span class="line">            state[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        state[<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>) &#123;</span><br><span class="line">        flip_vertical(state[<span class="number">0</span>]);</span><br><span class="line">        flip_vertical(<span class="number">1</span> - state[<span class="number">0</span>]);</span><br><span class="line">        state[<span class="number">0</span>] = <span class="number">1</span> - state[<span class="number">0</span>];</span><br><span class="line">        state[<span class="number">1</span>] = <span class="number">95</span> - state[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] != <span class="number">35</span>) &#123;</span><br><span class="line">            state[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        state[<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maze[state[<span class="number">0</span>]][state[<span class="number">1</span>] * <span class="number">96</span> + state[<span class="number">2</span>]] == <span class="number">35</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func_num</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (func(num &gt;&gt; <span class="number">6</span>, state) || func((num &lt;&lt; <span class="number">2</span>) % <span class="number">256</span> &gt;&gt; <span class="number">6</span>, state) || func((num &lt;&lt; <span class="number">4</span>) % <span class="number">256</span> &gt;&gt; <span class="number">6</span>, state) || func((num &lt;&lt; <span class="number">6</span>) % <span class="number">256</span> &gt;&gt; <span class="number">6</span>, state)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">brute_force_maze</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">32</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">32</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    maze[<span class="number">0</span>][i * N + j] = temp[<span class="number">0</span>][i * N + j];</span><br><span class="line">                    maze[<span class="number">1</span>][i * N + j] = temp[<span class="number">1</span>][i * N + j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                state[i] = state_copy[i];</span><br><span class="line">            &#125;</span><br><span class="line">            func_num(<span class="number">49</span>);</span><br><span class="line">            func_num(i);</span><br><span class="line">            func_num(<span class="number">49</span>);</span><br><span class="line">            func_num(j);</span><br><span class="line">            <span class="keyword">if</span> (state[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; state[<span class="number">1</span>] == <span class="number">20</span> &amp;&amp; state[<span class="number">2</span>] == <span class="number">33</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c %c %c %c\n&quot;</span>,<span class="number">49</span>,i,<span class="number">49</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="comment">//print_matrix(state);</span></span><br><span class="line">    <span class="type">int</span> test[] = &#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;@&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        func_num(test[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            temp[<span class="number">0</span>][i * N + j] = maze[<span class="number">0</span>][i * N + j];</span><br><span class="line">            temp[<span class="number">1</span>][i * N + j] = maze[<span class="number">1</span>][i * N + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        state_copy[i] = state[i];</span><br><span class="line">    &#125;</span><br><span class="line">    brute_force_maze();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果： 1 - 1 ;</span></span><br></pre></td></tr></table></figure></div>

<p>然后直接对每两个存档点之间暴力枚举即可（例如以上就是枚举第3-4个存档点之间字节）</p>
<p>最终得到wctf{$cr@tcH1-1;K3-4-1337~c47-2}</p>
]]></content>
      <tags>
        <tag>reverse</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
</search>
